// Planter Generator - Vase Mode v4.3.0
// by Oohhddaanngg (MTin3D)
// Spiral-vase planter bodies + conformal saucers. Tuned for 0.8 mm vase mode.
// Styles (marketing names): Helix, Ripple, Strata, Serif Flow

/* Quick print notes:
   - Slice planters in Spiral/Vase mode (top layers = 0).
   - Bottom layers sum to bottom_thickness.
   - 0.8 mm nozzle recommended for tall vases; 0.2–0.3 mm layer height works well.
*/

// ---------- Global Quality Controls ----------
/* [Print Settings] */
// Higher = more polygons, which means smoother curves and cleaner twist transitions
detail_level = 1.6; // [0.5:0.1:3.0]
// Slicer bottom layers should sum to this thickness (mm)
bottom_thickness = 3.2; // [1.6:0.8:6.4]

base_fn = max(48, min(160, floor(64*detail_level)));
$fn = base_fn; $fa = 6; $fs = 0.8;

// ==============================
// [1] Style Selection
// ==============================
/* [Style Selection]
   Helix — refined spiral lift
   Ripple — rhythmic radial waves
   Strata — organic layered contours
   Serif Flow — fluted silhouette with an elegant S-curve
*/
// Choose planter body style
planter_style = "Ripple"; // [Helix, Ripple, Strata, Serif Flow]


// ==============================
// [2] Size Options
// ==============================
/* [Size Options] */
// Pick preset (Top x Height, Base) or Custom
size_preset = "Standard"; // [Custom, Herb Pot (Top100 x H90, base70), Succulent Bowl (Top80 x H50, base65), Seedling Pot (Top102 x H100, base75), Standard Pot (Top152 x H140, base100), Large Pot (Top203 x H180, base140), Orchid Pot (Top140 x H160, base90), Cactus Planter (Top90 x H110, base70)]

// Top outside diameter (mm)
top_diameter = 120; // [60:5:240]
// Overall height (mm)
height = 100; // [50:5:250]
// Bottom outside diameter (mm)
bottom_diameter = 80; // [40:5:200]


// ==============================
// [3] Helix Style Settings (formerly Twisted)
// ==============================
/* [Helix Style Settings] */
// Twist over full height, in degrees
helix_amount = 60; // [0:5:360]
// Base polygon sides (lower = chunkier lobes)
helix_sides = 6; // [3:1:24]
// Vertex rounding at polygon corners (mm)
helix_rounding = 3; // [0:0.5:4]

// ==============================
// [4] Ripple Style Settings (formerly Wave)
// ==============================
/* [Ripple Style Settings] */
// Ripples around the planter
ripple_count = 8; // [2:1:20]
// Amplitude of radius in %
ripple_amplitude = 12; // [5:1:24]
// Vertical variation factor
ripple_vertical_freq = 0.5; // [0:0.1:2]
// Add helical drift
ripple_spiral = true; // [true, false]
// Drift amount (deg)
ripple_spiral_amount = 45; // [0:5:180]

// ==============================
// [5] Strata Style Settings (formerly Topographical)
// ==============================
/* [Strata Style Settings] */
// Number of organic bands (layers)
strata_layers = 20; // [10:1:80]
// Variation as % of diameter
strata_variation = 15; // [5:1:30]
// Noise seed
strata_seed = 42; // [1:1:999]
// Integer step for weighting (coarse→fine)
strata_smoothness = 3; // [1:1:5]
// Add slow spiral
strata_spiral = false; // [true, false]
// Spiral amount (deg)
strata_spiral_amount = 30; // [0:5:90]

// ==============================
// [6] Serif Flow Style Settings (new S-curve fluted look)
// ==============================
/* [Serif Flow Style Settings] */
// Number of vertical flutes
serif_flute_count = 24; // [12:1:36]
// Flute depth as % of radius
serif_flute_depth = 12; // [6:1:20]
// Edge softening (mm) for crisper/softer ribs
serif_rounding = 1.5; // [0:0.5:3]
// Mid-height side-shear amplitude (deg)
serif_shear_amplitude = 32; // [0:2:50]
// Number of S-bends along height
serif_shear_cycles = 1; // [0:1:3]
// Where the S-bend peaks around the circumference (deg)
serif_shear_phase = 0; // [0:15:345]
// Gentle top taper (%) to refine silhouette
serif_taper_pct = 3; // [0:1:8]

// ==============================
// [7] Drainage
// ==============================
/* [Drainage] */
// Cut drainage through slicer-made bottom
drainage_holes = true; // [true, false]
// Pattern (Auto clamps ring count safely)
drainage_pattern = "Ring"; // [Center, Ring, Grid, Triangle, Auto]
// Hole diameter (mm)
hole_diameter = 8; // [4:1:15]
// In Grid: target total holes; Ring: count
hole_count = 6; // [1:1:25]

// ==============================
// [8] Saucer (conformal by default, matches planter base)
// ==============================
/* [Saucer] */
// Match planter footprint (true) or use round saucer (false)
saucer_match_shape = true; // [true, false]
// Saucer wall height (mm)
saucer_height = 15; // [10:1:30]
// Saucer wall thickness (mm)
saucer_wall_thickness = 1.2; // [1.0:0.1:3]
// Saucer floor thickness (mm)
saucer_floor_thickness = 1.2; // [1.0:0.1:3]
// Clearance between planter and saucer (mm) — radial
saucer_gap = 3; // [2:0.5:10]
// Extra vertical lip height (mm)
saucer_rim = 1; // [0.5:0.5:5]

// Master switch for generating the saucer (used by Export Options)
generate_saucer = true; // [true, false]

/* [Saucer Details] */
// Radial support ribs
saucer_ribs = true; // [true, false]
// Number of ribs
saucer_rib_count = 6; // [4:1:12]
// Rib bar width (mm, conformal saucer)
saucer_rib_width = 2; // [1:0.5:4]
// Rib height (mm)
saucer_rib_height = 5; // [2:0.5:10]

// ==============================
// [9] Export Options
// ==============================
/* [Export Options] */
// Choose what to render/export
export_mode = "Both Together"; // [Planter Only, Saucer Only, Both Together]

// ---------- Helpers ----------
function clampv(x,a,b) = min(max(x,a), b);
function prand(seed, idx) = ((seed*9301 + idx*49297) % 233280) / 233280;

// Presets (ASCII-only to avoid UI quirks)
function get_preset_dims(p) =
    p=="Herb Pot (Top100 x H90, base70)"       ? [100, 70, 90]  :
    p=="Succulent Bowl (Top80 x H50, base65)"  ? [80, 65, 50]   :
    p=="Seedling Pot (Top102 x H100, base75)"  ? [102, 75, 100] :
    p=="Standard Pot (Top152 x H140, base100)" ? [152, 100, 140]:
    p=="Large Pot (Top203 x H180, base140)"    ? [203, 140, 180]:
    p=="Orchid Pot (Top140 x H160, base90)"    ? [140, 90, 160] :
    p=="Cactus Planter (Top90 x H110, base70)" ? [90, 70, 110]  :
    [top_diameter, bottom_diameter, height];

dims = get_preset_dims(size_preset);
final_top_d = dims[0];
final_bottom_d = dims[1];
final_height = dims[2];

// ---------- Footprints (2D) ----------
module footprint_helix(d_bot){
    if (helix_rounding > 0)
        offset(r=helix_rounding) offset(r=-helix_rounding)
            circle(d=d_bot, $fn=helix_sides);
    else
        circle(d=d_bot, $fn=helix_sides);
}

module footprint_ripple(d_bot){
    a_count = base_fn;
    pts = [
        for (t = [0:a_count-1])
            let(a = t * 360 / a_count)
            let(off = sin(a*ripple_count) * (ripple_amplitude/100))
            let(r = (d_bot/2) * (1 + off))
            [ r*cos(a), r*sin(a) ]
    ];
    polygon(points=pts);
}

module footprint_strata(d_bot){
    taps = 3; sum = 0;
    for (k = [0:taps]){
        j = k * strata_smoothness;
        w = 1 / (j/strata_smoothness + 1);
        sum = sum + prand(strata_seed + j, 0) * w;
    }
    norm = sum / 2;
    d0 = d_bot * (1 + (norm - 0.5) * (strata_variation/100));
    offset(r=1) offset(r=-1) circle(d=d0, $fn=base_fn);
}

module footprint_serif(d_bot){
    // fluted circle (cos gives sharper rib crests)
    a_count = base_fn;
    pts = [
        for (t = [0:a_count-1])
            let(a = t * 360 / a_count)
            let(off = cos(a*serif_flute_count) * (serif_flute_depth/100))
            let(r = (d_bot/2) * (1 + off))
            [ r*cos(a), r*sin(a) ]
    ];
    if (serif_rounding > 0)
        offset(r=serif_rounding) offset(r=-serif_rounding) polygon(points=pts);
    else
        polygon(points=pts);
}

module planter_footprint(d_bot){
    if (planter_style == "Helix")       footprint_helix(d_bot);
    else if (planter_style == "Ripple") footprint_ripple(d_bot);
    else if (planter_style == "Serif Flow") footprint_serif(d_bot);
    else                                footprint_strata(d_bot); // Strata
}

// ---------- Planter bodies (spiral-friendly) ----------
module helix_planter() {
    scale_ratio = final_top_d / final_bottom_d;
    linear_extrude(height=final_height, twist=helix_amount, scale=scale_ratio)
        footprint_helix(final_bottom_d);
}

module ripple_planter() {
    slices = clampv( round(30*detail_level*(1 + ripple_vertical_freq)), 24, 120 );
    a_count = base_fn;
    union() {
        for (i = [0:slices-1]) {
            z0 = i * final_height / slices;
            z1_nom = (i+1) * final_height / slices;
            z1 = (i == slices-1) ? final_height : z1_nom + 0.05;  // tiny overlap
            h_seg = max(0.06, z1 - z0);

            base_d = final_bottom_d + (final_top_d - final_bottom_d) * (z0 / final_height);
            spiral_term = ripple_spiral ? (z0 * ripple_spiral_amount / final_height) : 0;
            vterm = z0 * ripple_vertical_freq * 360 / final_height;

            pts = [
                for (t = [0:a_count-1]) 
                    let(a = t * 360 / a_count)
                    let(phase = a*ripple_count + spiral_term + vterm)
                    let(off = sin(phase) * (ripple_amplitude/100))
                    let(r = (base_d/2) * (1 + off))
                    [ r*cos(a), r*sin(a) ]
            ];

            translate([0,0,z0])
                linear_extrude(height=h_seg)
                    polygon(points=pts);
        }
    }
}

module strata_planter() {
    layers = min(strata_layers, 120);
    layer_h = final_height / layers;

    union() {
        for (i = [0:layers-1]) {
            z0 = i * layer_h;
            z1 = (i == layers-1) ? final_height : (i+1)*layer_h + 0.05; // overlap
            h_seg = max(0.06, z1 - z0);

            base_d = final_bottom_d + (final_top_d - final_bottom_d) * (i / layers);

            taps = 3; sum = 0;
            for (k = [0:taps]) {
                j = k * strata_smoothness;
                w = 1 / (j/strata_smoothness + 1);
                sum = sum + prand(strata_seed + j, i) * w;
            }
            norm = sum / 2;
            current_d = base_d * (1 + (norm - 0.5) * (strata_variation/100));

            rot = strata_spiral ? (i * strata_spiral_amount / layers) : 0;

            translate([0,0,z0])
                rotate([0,0,rot])
                    linear_extrude(height=h_seg)
                        offset(r=1) offset(r=-1)
                            circle(d=current_d, $fn=base_fn);
        }
    }
}

// ---- Serif Flow planter (S-curve shear over fluted profile)
module serif_flow_planter() {
    // More slices when flutes are dense or shear is large
    slices = clampv(
        round(34*detail_level * (1 + serif_flute_count/30 + serif_shear_amplitude/40)),
        36, 200
    );
    a_count = base_fn;

    union() {
        for (i = [0:slices-1]) {
            // slice z span with generous vertical overlap for solid fusion
            z0 = i * final_height / slices;
            z1_nom = (i+1) * final_height / slices;
            overlap_z = max(0.2, 0.25 * (final_height / slices));  // ~25% of slice height, ≥0.2 mm
            z1 = (i == slices-1) ? final_height : min(final_height, z1_nom + overlap_z);
            h_seg = max(0.2, z1 - z0);


            // base diameter with gentle top taper
            t = z0 / final_height;
            // linear blend then taper factor
            d_lin = final_bottom_d + (final_top_d - final_bottom_d) * t;
            d_taper = d_lin * (1 - (serif_taper_pct/100) * t);
            base_d = d_taper;

            // shear angle with end-fade envelope (zero at ends, peak mid-height)
            env = sin(180*t); // 0 at t=0/1, 1 at t=0.5
            theta = serif_shear_amplitude * sin(360*serif_shear_cycles*t + serif_shear_phase) * env;

            // fluted footprint at this z
            pts = [
                for (k = [0:a_count-1])
                    let(a = k * 360 / a_count)
                    let(off = cos(a*serif_flute_count) * (serif_flute_depth/100))
                    let(r = (base_d/2) * (1 + off))
                    [ r*cos(a), r*sin(a) ]
            ];

            translate([0,0,z0])
                rotate([0,0,theta])
                    linear_extrude(height=h_seg)
                        // optional rounding for crisp but printable ribs
                        { if (serif_rounding > 0)
                              offset(r=serif_rounding) offset(r=-serif_rounding) polygon(points=pts);
                          else
                              polygon(points=pts);
                        }
        }
    }
}

module planter_body() {
    if (planter_style == "Helix")       helix_planter();
    else if (planter_style == "Ripple") ripple_planter();
    else if (planter_style == "Serif Flow") serif_flow_planter();
    else                                  strata_planter(); // Strata
}

// ---------- Drainage patterns ----------
module drainage_holes_pattern(d_bot) {
    if (drainage_pattern == "Center") {
        circle(d=hole_diameter);
    } else if (drainage_pattern == "Ring" || drainage_pattern == "Auto") {
        perim = 3.1415926536 * d_bot;
        max_by_perim = floor(perim / (3*hole_diameter)); // ~3xD spacing
        safe_count = max(3, max_by_perim);
        cnt = (drainage_pattern == "Auto") ? min(hole_count, safe_count) : hole_count;
        if (drainage_pattern == "Auto" && hole_count > safe_count)
            echo("Info: Auto ring hole_count clamped to ", safe_count);
        for (i = [0:cnt-1]) {
            rotate(i * 360/cnt)
                translate([d_bot/4, 0])
                    circle(d=hole_diameter);
        }
    } else if (drainage_pattern == "Grid") {
        n = ceil(sqrt(hole_count));
        usable_r = max(0, d_bot/2 - 1.25*hole_diameter);
        if (n <= 1) {
            circle(d=hole_diameter);
        } else {
            step = (2*usable_r)/(n-1);
            for (k = [0:hole_count-1]) {
                ix = floor(k % n);
                iy = floor(k / n);
                cx = -usable_r + ix*step;
                cy = -usable_r + iy*step;
                if (cx*cx + cy*cy <= usable_r*usable_r)
                    translate([cx, cy]) circle(d=hole_diameter);
            }
        }
    } else { // Triangle
        for (i = [0:2]) {
            rotate(i * 120)
                translate([max(d_bot/6, hole_diameter*0.9), 0])
                    circle(d=hole_diameter);
        }
    }
}

// ---------- Planter with drainage subtraction ----------
module planter_with_features() {
    difference() {
        planter_body();
        if (drainage_holes) {
            translate([0, 0, -0.1])
                linear_extrude(height=bottom_thickness + 0.3)
                    drainage_holes_pattern(final_bottom_d);
        } else {
            echo("Warning: Drainage disabled; plants may waterlog.");
        }
    }
}

// ---------- Saucers ----------
module saucer_conformal(d_bot){
    difference(){
        linear_extrude(height=saucer_height)
            offset(delta = saucer_gap + saucer_rim + saucer_wall_thickness)
                planter_footprint(d_bot);
        translate([0,0,saucer_floor_thickness])
            linear_extrude(height=saucer_height)
                offset(delta = saucer_gap)
                    planter_footprint(d_bot);
    }
    if (saucer_ribs){
        intersection(){
            translate([0,0,saucer_floor_thickness])
                linear_extrude(height=saucer_rib_height)
                    offset(delta = saucer_gap)
                        planter_footprint(d_bot);
            union(){
                span = d_bot + 2*(saucer_gap + saucer_rim + saucer_wall_thickness);
                for (i=[0:saucer_rib_count-1]){
                    rotate(i*360/saucer_rib_count)
                        translate([0,0,saucer_floor_thickness])
                            linear_extrude(height=saucer_rib_height)
                                square([span, saucer_rib_width], center=true);
                }
            }
        }
    }
}

module saucer_round(d_bot){
    inner_d1 = d_bot + 2*saucer_gap; // diameter uses 2*radial gap
    outer_d1 = inner_d1 + 2*(saucer_rim + saucer_wall_thickness);
    difference() {
        cylinder(h=saucer_height, d=outer_d1, $fn=max(48, floor(base_fn*0.8)));
        translate([0, 0, saucer_floor_thickness])
            cylinder(h=saucer_height, d=inner_d1, $fn=max(48, floor(base_fn*0.8)));
    }
    if (saucer_ribs) {
        inner_r = inner_d1/2;
        rib_end_r = max(1.2, inner_r - 3);
        for (i = [0:saucer_rib_count-1]) {
            rotate(i * 360/saucer_rib_count)
                translate([0, 0, saucer_floor_thickness])
                    hull() {
                        cylinder(h=saucer_rib_height, r=1.6, $fn=24);
                        translate([rib_end_r, 0, 0]) cylinder(h=saucer_rib_height, r=1.6, $fn=24);
                    }
        }
    }
}

module saucer_auto(d_bot){
    if (saucer_match_shape) saucer_conformal(d_bot);
    else                    saucer_round(d_bot);
}

// ---------- Export assembly ----------
// Tightened layout: half-widths + ~10 mm margin
function saucer_outer_span(d_bot) = d_bot + 2*(saucer_gap + saucer_rim + saucer_wall_thickness);
desired_layout_gap = 10;
spacing = (final_top_d/2) + (saucer_outer_span(final_bottom_d)/2) + desired_layout_gap;

if (export_mode == "Planter Only") {
    planter_with_features();
} else if (export_mode == "Saucer Only") {
    if (generate_saucer) { saucer_auto(final_bottom_d); }
} else { // Both Together
    planter_with_features();
    if (generate_saucer) {
        translate([spacing, 0, 0]) saucer_auto(final_bottom_d);
    }
}

// ---------- Validation & printability echoes ----------
if (final_top_d <= 0 || final_bottom_d <= 0 || final_height <= 0)
    echo("ERROR: All dimensions must be positive");
if (bottom_thickness < 2)
    echo("Warning: Bottom thickness < 2mm may be fragile");
if (saucer_wall_thickness < 1.2)
    echo("Warning: Saucer wall thickness < 1.2mm may be fragile with FDM.");
if (ripple_amplitude > 20 && ripple_count >= 12)
    echo("Warning: Aggressive Ripple (amp>20% & count>=12) may create >55° overhangs near the base.");

echo("Info: Planter body is for SPIRAL VASE mode. Enable Vase/Spiral in slicer.");
echo(str("Hint: Set bottom layers >= ",
         ceil(bottom_thickness / 0.4),
         " at 0.4 mm layer height (scale accordingly). Top layers = 0."));
if (saucer_match_shape)
    echo("Info: Saucer matches planter footprint.");
