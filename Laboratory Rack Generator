// Lab Rack Generator v2.11 — soft externals + rounded hole entry + micro rim break
// - Cups: unchanged approach (carve from bottom, then flip plate) to ensure cups face upward
// - External edges: Minkowski fillet on base solids only, then subtract features
// - Holes: optional Rounded (stepped) lead-in at top; plus tiny outer rim break (micro-chamfer)

$fn = 64; $fa = 6; $fs = 0.8;

/* [Rack Family] */
rack_family = "12x75 Test Tube Rack"; // [12x75 Test Tube Rack, Antisera Rack]

/* [Plate Geometry] */
plate_width       = 126.8;
plate_depth       = 255.8;
plate_thickness   = 5.0;    // [3:10]

/* [Edge Finish] */
edge_radius = 0.4;   // [0:0.1:1.0] external fillet on plates & end piece (mm)

/* [Borders] */
border_left_center   = 12.40;
border_right_center  = 12.40;
border_top_center    = 17.40;
border_bottom_center = 17.40;
lock_symmetry = "On"; // [On, Off]

/* [Grid & Fit] */
auto_fit = true;       // [true, false]
wall_thickness = 3.0;  // [3.0:0.1:9.0]

/* [Plate – Holes] */
holes_leadin       = "On"; // [On, Off]
lead_in_profile    = "Conical (fast)"; // [Conical (fast), Rounded (stepped)]
lead_in_steps      = 10;   // [6:1:20] only for Rounded (stepped)
container_diameter = 12.8;
clearance_extra    = 0.0;
lead_in_height     = 1.8;  // [0:0.2:3]
lead_in_factor     = 1.6;  // [1.0:0.05:2.4]

/* Hole top rim micro-break (independent of main lead-in) */
hole_outer_break_enable = true;
hole_outer_break_height = 0.35;  // [0:0.05:0.6] height of micro-chamfer
hole_outer_break_extra  = 0.6;   // [0:0.1:1.2] added DIAMETER at the very top (tapers to 0)

/* [Plate – Cups] */
cup_depth        = 4.0;
cup_floor_min    = 1.0;
cup_drain_enable = false;
cup_drain_diam   = 1.0;

/* Rim control for cups */
cup_rim_mode       = "Ratio";   // [Match holes, Ratio]
cup_diameter_ratio = 0.85;      // [0.7:0.05:0.95] used only when mode == Ratio

/* [End Piece (Press-fit)] */
pf_cheek_thickness = 8.0;
pf_tier_spacing    = 22.0;
pf_visible_overlap = 2.0;
pf_pocket_depth    = 3.0;
pf_pocket_fit      = 0.25;
pf_vertical_grip   = 0.05;
pf_bottom_foot     = 6.0;
pf_top_cap         = 6.0;

/* [Antisera Rack] */
as_tiers       = 3;           // [1:6]
as_shelf_thk   = 5.0;
as_rise        = 32.0;
as_run         = 42.0;
as_cheek_thk   = 7.0;
as_cheek_depth = 127.0;

/* [Export] */
export_part = "All parts (flat)"; // [All parts (flat), Plate - Holes only, Plate - Cups only, End piece only, Antisera Rack (all flat)]

// ---------- Derived / guards ----------
$wall_min = 3.0;
wall_thk = wall_thickness < $wall_min ? $wall_min : wall_thickness;

actual_hole_d = container_diameter + clearance_extra;
lead_in_on    = (holes_leadin == "On");
lead_in_radius = lead_in_on ? (actual_hole_d*(lead_in_factor-1)/2) : 0;

module warn(m){ echo(str("[WARN] ", m)); }
if (cup_floor_min < 1.0) warn("cup_floor_min is thin; consider ≥1.5–2.0 mm.");
// Floor-safety guard for cups
if (cup_depth > (plate_thickness - cup_floor_min))
    warn("cup_depth exceeds allowed depth; would violate cup_floor_min.");

// Lead-in guard vs wall thickness
_leadin_r_add = (holes_leadin=="On") ? (actual_hole_d*(lead_in_factor-1)/2) : 0;
if (_leadin_r_add > wall_thk/2)
    warn("Lead-in too aggressive for wall_thickness; rims may merge. Reduce lead_in_factor or increase wall_thickness.");

// Outer break guard (keep reasonable against wall thickness)
if (hole_outer_break_enable && hole_outer_break_extra > max(0.0, wall_thk-0.4))
    warn("hole_outer_break_extra may be large vs wall_thickness; consider reducing.");

// ---------- Symmetry handling ----------
function _L() = border_left_center;
function _R() = (lock_symmetry=="On") ? border_left_center  : border_right_center;
function _T() = border_top_center;
function _B() = (lock_symmetry=="On") ? border_top_center   : border_bottom_center;

// ---------- Grid ----------
function _pitch_h() = actual_hole_d + wall_thk;
function _cols_auto() = floor( (plate_width  - (_L()+_R())) / _pitch_h() ) + 1;
function _rows_auto() = floor( (plate_depth  - (_T()+_B())) / _pitch_h() ) + 1;
function _cols() = auto_fit ? max(1,_cols_auto()) : _cols_auto();
function _rows() = auto_fit ? max(1,_rows_auto()) : _rows_auto();
function _avail_x() = plate_width - (_L()+_R());
function _avail_y() = plate_depth - (_T()+_B());
function _occ_x() = actual_hole_d + (_cols()-1)*_pitch_h();
function _occ_y() = actual_hole_d + (_rows()-1)*_pitch_h();
function _slack_x() = _avail_x() - _occ_x();
function _slack_y() = _avail_y() - _occ_y();
function _x0() = (lock_symmetry=="On") ? (_L() + _slack_x()/2 + actual_hole_d/2) : (_L() + actual_hole_d/2);
function _y0() = (lock_symmetry=="On") ? (_T() + _slack_y()/2 + actual_hole_d/2) : (_T() + actual_hole_d/2);
function cx(ix) = _x0() + ix*_pitch_h();
function cy(iy) = _y0() + iy*_pitch_h();

/* --- Rounded externals (keeps original size) --- */
module rounded_block(w,d,h,r){
    R = (r>0) ? min(r, 0.49*min(w,d,h)) : 0;
    if (R <= 0) cube([w,d,h]);
    else
        minkowski() {
            translate([R,R,R]) cube([w-2*R, d-2*R, h-2*R]);
            sphere(r=R, $fn=36);
        }
}

// ---------- primitives & helpers ----------

// Rounded (spherical) lead-in at the TOP face, approximated by stacked frustums
module hole_leadin_rounded(xc, yc, h, d_base, d_top, steps){
    r_t = d_top/2;
    r_b = d_base/2;
    zc = (r_b*r_b - r_t*r_t + h*h)/(2*h);
    R  = sqrt(max(0, r_t*r_t + zc*zc));
    dz = h/steps;
    for (i=[0:steps-1]){
        z0 = i*dz;  z1 = (i+1)*dz;
        r0 = sqrt(max(0, R*R - (z0 - zc)*(z0 - zc)));
        r1 = sqrt(max(0, R*R - (z1 - zc)*(z1 - zc)));
        translate([xc, yc, plate_thickness - h + z0])
            cylinder(h=(z1-z0)+0.0005, d1=2*r1, d2=2*r0, $fn=max(36, ceil($fn*0.75)));
    }
}

// Tiny outer rim break (micro-chamfer) at the very top edge of the hole
module hole_outer_break(xc, yc){
    if (hole_outer_break_enable && hole_outer_break_height>0 && hole_outer_break_extra>0){
        translate([xc, yc, plate_thickness - hole_outer_break_height + 0.05])
            cylinder(h=hole_outer_break_height, 
                     d1=actual_hole_d, 
                     d2=actual_hole_d + hole_outer_break_extra,
                     $fn=max(48,$fn)); // subtract to widen just at the top
    }
}

// Through-hole + optional top lead-in + optional outer rim break
module hole_at(xc,yc){
    // Through hole
    translate([xc,yc,-0.1]) cylinder(h=plate_thickness+0.4, d=actual_hole_d);

    // Lead-in (internal, top-anchored)
    if (holes_leadin=="On" && lead_in_height>0){
        d_top = actual_hole_d*lead_in_factor;
        if (lead_in_profile == "Conical (fast)"){
            translate([xc,yc,plate_thickness - lead_in_height + 0.1])
                cylinder(h=lead_in_height, d1=d_top, d2=actual_hole_d);
        } else { // "Rounded (stepped)"
            hole_leadin_rounded(xc, yc, lead_in_height, actual_hole_d, d_top, lead_in_steps);
        }
    }

    // Outer rim micro-chamfer (very top edge), independent of the lead-in
    hole_outer_break(xc, yc);
}

// --- Cup rim diameter selection ---
function _cup_rim_d() =
    (cup_rim_mode == "Match holes") ? actual_hole_d : (actual_hole_d * cup_diameter_ratio);

// --- Cup subtractor (carve from bottom, then plate is flipped) ---
module cup_spherical_at(xc, yc) {
    h_eff = min(cup_depth, max(0.1, plate_thickness - cup_floor_min));
    Ds = _cup_rim_d();
    R = (h_eff*h_eff + (Ds/2)*(Ds/2)) / (2*h_eff);
    if (is_undef(R) || R <= 0) warn("Invalid sphere radius for cup.");

    // Anti-coplanar epsilon so tangent ring isn't exactly coplanar with a plate face
    eps_cup = 0.05; // 50 µm

    // Position sphere so it carves from the bottom (pre-flip); tiny offset downward
    z_sphere_center = (h_eff - R) - eps_cup;

    // Spherical depression
    translate([xc, yc, z_sphere_center])
        sphere(r = R, $fn = 96);

    // Optional straight drain
    if (cup_drain_enable)
        translate([xc, yc, -0.2])
            cylinder(h = plate_thickness + 0.6, d = cup_drain_diam, $fn = 32);
}

// ---------- plates ----------
module plate_holes(){
    difference(){
        rounded_block(plate_width, plate_depth, plate_thickness, edge_radius);
        for (ix=[0:_cols()-1]) for (iy=[0:_rows()-1]) hole_at(cx(ix), cy(iy));
    }
}

// Plate with spherical cups - built upside down then flipped
module plate_cups() {
    // Flip the entire plate so cups face upward in all viewers/slicers
    translate([0, plate_depth, 0])
    rotate([180, 0, 0])
    difference() {
        rounded_block(plate_width, plate_depth, plate_thickness, edge_radius);
        for (ix=[0:_cols()-1]) for (iy=[0:_rows()-1]) cup_spherical_at(cx(ix), cy(iy));
    }
}

// ---------- end piece ----------
function _stack_height_2tiers() = pf_bottom_foot + 2*plate_thickness + pf_tier_spacing + pf_top_cap;
function _pocket_w()  = plate_thickness + pf_pocket_fit;
function _pocket_h()  = plate_thickness - pf_vertical_grip;

module end_piece(){
    cheek_w = pf_cheek_thickness;
    cheek_d = pf_pocket_depth + pf_visible_overlap;
    cheek_h = _stack_height_2tiers();
    difference(){
        rounded_block(cheek_w, cheek_d, cheek_h, edge_radius);
        // lower pocket (cups plate)
        translate([0, pf_visible_overlap, pf_bottom_foot])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]);
        // upper pocket (holes plate)
        translate([0, pf_visible_overlap, pf_bottom_foot + plate_thickness + pf_tier_spacing])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]);
    }
}

/* Antisera placeholders */
module antisera_cheek(){
    linear_extrude(height=as_cheek_thk)
        polygon(points=[[0,0],[as_cheek_depth,0],[as_cheek_depth, as_tiers*(as_shelf_thk+as_rise)-as_rise],
                        [0,        as_tiers*(as_shelf_thk+as_rise)-as_rise]]);
}
module antisera_shelf(){ plate_holes(); }

// ---------- flat layouts ----------
module layout_12x75_flat(){
    gap = 12;
    translate([0,0,0]) end_piece();
    translate([pf_cheek_thickness + gap, 0, 0]) plate_cups();
    translate([pf_cheek_thickness + gap + plate_width + gap, 0, 0]) plate_holes();
}
module layout_antisera_flat(){
    gap = 12;
    translate([0,0,0]) antisera_cheek();
    translate([as_cheek_thk + gap, 0, 0]) antisera_cheek();
    translate([2*(as_cheek_thk + gap), 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + plate_width + gap, 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + 2*(plate_width + gap), 0, 0]) antisera_shelf();
}

// ---------- exporter ----------
if (rack_family == "12x75 Test Tube Rack"){
    if      (export_part == "All parts (flat)")  layout_12x75_flat();
    else if (export_part == "Plate - Holes only") plate_holes();
    else if (export_part == "Plate - Cups only")  plate_cups();
    else if (export_part == "End piece only")     end_piece();
    else { warn(str("Unknown export_part: ", export_part, " — defaulting to All parts (flat).")); layout_12x75_flat(); }
} else {
    if (export_part == "Antisera Rack (all flat)") layout_antisera_flat();
    else { warn(str("Unknown export_part for Antisera: ", export_part, " — defaulting to Antisera Rack (all flat).")); layout_antisera_flat(); }
}

// ---------- diagnostics ----------
h_eff_dbg = min(cup_depth, max(0.1, plate_thickness - cup_floor_min));
cup_rim_dbg = _cup_rim_d();
echo("=== Test Tube Rack Configuration ===");
echo(str("Grid: ", _cols(), " x ", _rows(), " = ", _cols()*_rows(), " positions"));
echo(str("Plate size: ", plate_width, " x ", plate_depth, " x ", plate_thickness, " mm"));
echo(str("Hole diameter: ", actual_hole_d, " mm"));
echo(str("Lead-in: ", holes_leadin, " (", lead_in_profile, "), height=", lead_in_height, " mm"));
echo(str("Outer rim break: ", hole_outer_break_enable ? "On" : "Off", 
         " (h=", hole_outer_break_height, " mm, +", hole_outer_break_extra, " mm @ top)"));
echo(str("Cup depth (effective): ", h_eff_dbg, " mm"));
echo(str("Cup rim diameter (actual): ", cup_rim_dbg, " mm"));
echo(str("Cup sphere radius: ", (h_eff_dbg*h_eff_dbg + (cup_rim_dbg/2)*(cup_rim_dbg/2)) / (2*h_eff_dbg), " mm"));
