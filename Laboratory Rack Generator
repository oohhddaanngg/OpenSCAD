// Lab Rack Generator v2.6 — 12x75 Test Tube Rack + Antisera Rack
// Change: Option B anchoring — cups generated in a local frame where TOP=Z0,
// so we always subtract the upper spherical cap (cups open on top face).

$fn = 64; $fa = 6; $fs = 0.8;

/* [Rack Family] */
rack_family = "12x75 Test Tube Rack"; // [12x75 Test Tube Rack, Antisera Rack]

/* [Plate Geometry] */
plate_width       = 126.8;
plate_depth       = 255.8;
plate_thickness   = 5.0;    // [3:10]

/* [Borders] */
border_left_center   = 12.40;
border_right_center  = 12.40;
border_top_center    = 17.40;
border_bottom_center = 17.40;
lock_symmetry = "On"; // [On, Off]

/* [Grid & Fit] */
auto_fit = true;       // [true, false]
wall_thickness = 3.0;  // [3.0:0.1:9.0]

/* [Plate – Holes] */
holes_leadin       = "On"; // [On, Off]
container_diameter = 12.8;
clearance_extra    = 0.0;
lead_in_height     = 1.8;  // [0:0.2:3]
lead_in_factor     = 1.6;  // [1.0:0.05:2.4]

/* [Plate – Cups] */
cup_depth        = 3.0;   // target spherical-bowl depth
cup_floor_min    = 2.0;   // minimum solid floor
cup_drain_enable = false; // Off by default
cup_drain_diam   = 1.2;   // only used when enabled

/* [End Piece (Press-fit)] */
pf_cheek_thickness = 8.0;
pf_tier_spacing    = 22.0;
pf_visible_overlap = 2.0;
pf_pocket_depth    = 3.0;
pf_pocket_fit      = 0.25;
pf_vertical_grip   = 0.05;
pf_bottom_foot     = 6.0;
pf_top_cap         = 6.0;

/* [Antisera Rack] */
as_tiers       = 3;           // [1:6]
as_shelf_thk   = 5.0;
as_rise        = 32.0;
as_run         = 42.0;
as_cheek_thk   = 7.0;
as_cheek_depth = 127.0;

/* [Export] */
export_part = "All parts (flat)"; // [All parts (flat), Plate - Holes only, Plate - Cups only, End piece only, Antisera Rack (all flat)]

// ---------- Derived / guards ----------
$wall_min = 3.0;
wall_thk = wall_thickness < $wall_min ? $wall_min : wall_thickness;

actual_hole_d = container_diameter + clearance_extra;
lead_in_on    = (holes_leadin == "On");
lead_in_radius = lead_in_on ? (actual_hole_d*(lead_in_factor-1)/2) : 0;

module warn(m){ echo(str("[WARN] ", m)); }
if (cup_floor_min < 1.5) warn("cup_floor_min is thin; consider ≥1.5–2.0 mm.");
if (plate_thickness <= cup_floor_min) warn("plate_thickness must be > cup_floor_min.");

function _min_border_needed() = pf_visible_overlap + 1.2 + lead_in_radius;
if (border_left_center  < _min_border_needed())  warn(str("Left border too small; need ≥ ", _min_border_needed()));
if (border_right_center < _min_border_needed())  warn(str("Right border too small; need ≥ ", _min_border_needed()));

// ---------- Symmetry handling ----------
function _L() = border_left_center;
function _R() = (lock_symmetry=="On") ? border_left_center  : border_right_center;
function _T() = border_top_center;
function _B() = (lock_symmetry=="On") ? border_top_center   : border_bottom_center;

// ---------- Grid (single source of truth) ----------
function _pitch_h() = actual_hole_d + wall_thk;

function _cols_auto() = floor( (plate_width  - (_L()+_R())) / _pitch_h() ) + 1;
function _rows_auto() = floor( (plate_depth  - (_T()+_B())) / _pitch_h() ) + 1;

function _cols() = auto_fit ? max(1,_cols_auto()) : _cols_auto();
function _rows() = auto_fit ? max(1,_rows_auto()) : _rows_auto();

function _avail_x() = plate_width - (_L()+_R());
function _avail_y() = plate_depth - (_T()+_B());
function _occ_x() = actual_hole_d + (_cols()-1)*_pitch_h();
function _occ_y() = actual_hole_d + (_rows()-1)*_pitch_h();
function _slack_x() = _avail_x() - _occ_x();
function _slack_y() = _avail_y() - _occ_y();

function _x0() = (lock_symmetry=="On") ? (_L() + _slack_x()/2 + actual_hole_d/2)
                                       : (_L() + actual_hole_d/2);
function _y0() = (lock_symmetry=="On") ? (_T() + _slack_y()/2 + actual_hole_d/2)
                                       : (_T() + actual_hole_d/2);

function cx(ix) = _x0() + ix*_pitch_h();
function cy(iy) = _y0() + iy*_pitch_h();

// ---------- primitives ----------
module hole_at(xc,yc){
    translate([xc,yc,-0.1]) cylinder(h=plate_thickness+0.4, d=actual_hole_d);
    if (lead_in_on)
        translate([xc,yc,plate_thickness - lead_in_height + 0.1])
            cylinder(h=lead_in_height, d1=actual_hole_d*lead_in_factor, d2=actual_hole_d);
}

// ----- Spherical cup cutter (Option B: local top-frame anchoring) -----
module cup_spherical_at(xc, yc) {
    // Effective depth
    h_req = cup_depth;
    h_max = max(0.1, plate_thickness - cup_floor_min);
    h_eff = min(h_req, h_max);
    if (h_eff < 0.3) warn(str("cup depth very shallow (", h_eff, " mm) — slicers may simplify."));

    Ds = actual_hole_d;
    R  = (h_eff*h_eff + (Ds/2)*(Ds/2)) / (2*h_eff);
    if (is_undef(R) || R <= 0) warn("Invalid sphere radius for cup.");

    // Local frame: TOP surface at z=0, bottom at z=-plate_thickness
    // Sphere center just BELOW the top face; clip plane slightly below tangent
    eps = 0.05;
    zc_local     = -(R - h_eff);     // negative (below top)
    z_clip_local = -h_eff + eps;     // keep z >= this → upper cap only

    // Build in local frame at (xc,yc, topZ=0), then translate back up
    translate([xc, yc, plate_thickness])  // move local z=0 to global top face
        intersection() {
            translate([0,0,zc_local]) sphere(r = R, $fn = 96);
            // Half-space z >= z_clip_local
            translate([-1e3, -1e3, z_clip_local])
                cube([2e3, 2e3, 2e3], center=false);
        }

    // Optional tiny drain straight through (only when enabled)
    if (cup_drain_enable)
        translate([xc, yc, -0.2]) cylinder(h = plate_thickness + 0.6,
                                           d = cup_drain_diam, $fn = 32);
}

// ---------- plates ----------
module plate_holes(){
    difference(){
        cube([plate_width, plate_depth, plate_thickness]);
        for (ix=[0:_cols()-1])
        for (iy=[0:_rows()-1])
            hole_at(cx(ix), cy(iy));
    }
}

module plate_cups() {
    difference() {
        cube([plate_width, plate_depth, plate_thickness]);
        for (ix=[0:_cols()-1])
        for (iy=[0:_rows()-1])
            cup_spherical_at(cx(ix), cy(iy));
    }
}

// ---------- end piece ----------
function _stack_height_2tiers() = pf_bottom_foot + 2*plate_thickness + pf_tier_spacing + pf_top_cap;
function _pocket_w()  = plate_thickness + pf_pocket_fit;
function _pocket_h()  = plate_thickness - pf_vertical_grip;

module end_piece(){
    cheek_w = pf_cheek_thickness;
    cheek_d = pf_pocket_depth + pf_visible_overlap;
    cheek_h = _stack_height_2tiers();
    difference(){
        cube([cheek_w, cheek_d, cheek_h]);
        translate([0, pf_visible_overlap, pf_bottom_foot])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]); // lower pocket (cups plate)
        translate([0, pf_visible_overlap, pf_bottom_foot + plate_thickness + pf_tier_spacing])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]); // upper pocket (holes plate)
    }
}

/* Antisera placeholders */
module antisera_cheek(){
    linear_extrude(height=as_cheek_thk)
        polygon(points=[
            [0,0],
            [as_cheek_depth,0],
            [as_cheek_depth, as_tiers*(as_shelf_thk+as_rise)-as_rise],
            [0,              as_tiers*(as_shelf_thk+as_rise)-as_rise]
        ]);
}
module antisera_shelf(){ plate_holes(); }

// ---------- flat layouts ----------
module layout_12x75_flat(){
    gap = 12;
    translate([0,0,0]) end_piece();
    translate([pf_cheek_thickness + gap, 0, 0]) plate_cups();
    translate([pf_cheek_thickness + gap + plate_width + gap, 0, 0]) plate_holes();
}

module layout_antisera_flat(){
    gap = 12;
    translate([0,0,0]) antisera_cheek();
    translate([as_cheek_thk + gap, 0, 0]) antisera_cheek();
    translate([2*(as_cheek_thk + gap), 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + plate_width + gap, 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + 2*(plate_width + gap), 0, 0]) antisera_shelf();
}

// ---------- exporter ----------
if (rack_family == "12x75 Test Tube Rack"){
    if      (export_part == "All parts (flat)")  layout_12x75_flat();
    else if (export_part == "Plate - Holes only") plate_holes();
    else if (export_part == "Plate - Cups only")  plate_cups();
    else if (export_part == "End piece only")     end_piece();
    else { warn(str("Unknown export_part: ", export_part, " — defaulting to All parts (flat)."));
           layout_12x75_flat(); }
} else {
    if (export_part == "Antisera Rack (all flat)") layout_antisera_flat();
    else { warn(str("Unknown export_part for Antisera: ", export_part, " — defaulting to Antisera Rack (all flat)."));
           layout_antisera_flat(); }
}
