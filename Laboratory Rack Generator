// Lab Rack Generator v2.3 — 12x75 Test Tube Rack + Antisera Rack
// Fix: spherical cups are clipped to keep a solid floor (no unintended holes).

$fn = 64; $fa = 6; $fs = 0.8;

/* [Rack Family] */
rack_family = "12x75 Test Tube Rack"; // [12x75 Test Tube Rack, Antisera Rack]

/* [Plate Geometry] */
plate_width       = 126.8;
plate_depth       = 255.8;
plate_thickness   = 5.0;    // [3:10]

/* [Borders] */
border_left_center   = 12.40;
border_right_center  = 12.40;
border_top_center    = 17.40;
border_bottom_center = 17.40;
lock_symmetry = "On"; // [On, Off]

/* [Grid & Fit] */
auto_fit = true;       // [true, false]
wall_thickness = 3.0;  // [3.0:0.1:9.0]

/* [Plate – Holes] */
holes_leadin = "On"; // [On, Off]
container_diameter = 12.8;
clearance_extra    = 0.0;
lead_in_height     = 1.8;  // [0:0.2:3]
lead_in_factor     = 1.6;  // [1.0:0.05:2.4]

/* [Plate – Cups] */
cup_depth          = 3.0;     // requested spherical-bowl depth
cup_floor_min      = 2.0;     // minimum solid floor under each cup
cup_drain_enable   = false;   // Off by default
cup_drain_diam     = 1.2;     // used ONLY when enabled

/* [End Piece (Press-fit)] */
pf_cheek_thickness = 8.0;
pf_tier_spacing    = 22.0;
pf_visible_overlap = 2.0;
pf_pocket_depth    = 3.0;
pf_pocket_fit      = 0.25;
pf_vertical_grip   = 0.05;
pf_bottom_foot     = 6.0;
pf_top_cap         = 6.0;

/* [Antisera Rack] */
as_tiers      = 3;           // [1:6]
as_shelf_thk  = 5.0;
as_rise       = 32.0;
as_run        = 42.0;
as_cheek_thk  = 7.0;
as_cheek_depth= 127.0;

/* [Export] */
export_part = "All parts (flat)"; // [All parts (flat), Plate - Holes only, Plate - Cups only, End piece only, Antisera Rack (all flat)]

// ---------- Derived / guards ----------
$wall_min = 3.0;
wall_thk = wall_thickness < $wall_min ? $wall_min : wall_thickness;

actual_hole_d = container_diameter + clearance_extra;
lead_in_on = (holes_leadin == "On");
lead_in_radius = lead_in_on ? (actual_hole_d*(lead_in_factor-1)/2) : 0;

module warn(m){ echo(str("[WARN] ", m)); }
if (cup_floor_min < 0.8) warn("cup_floor_min is very thin; consider ≥1.5–2.0 mm.");
if (plate_thickness <= cup_floor_min) warn("plate_thickness must be > cup_floor_min.");

function _min_border_needed() = pf_visible_overlap + 1.2 + lead_in_radius;
if (border_left_center  < _min_border_needed())  warn(str("Left border too small; need ≥ ", _min_border_needed()));
if (border_right_center < _min_border_needed())  warn(str("Right border too small; need ≥ ", _min_border_needed()));

// ---------- Symmetry handling ----------
function _L() = lock_symmetry=="On" ? border_left_center : border_left_center;
function _R() = lock_symmetry=="On" ? _L() : border_right_center;
function _T() = lock_symmetry=="On" ? border_top_center : border_top_center;
function _B() = lock_symmetry=="On" ? _T() : border_bottom_center;

// ---------- Grid centers (shared by both plates) ----------
function _pitch_h() = actual_hole_d + wall_thk;

function _cols_auto() = floor( (plate_width - (_L()+_R())) / _pitch_h() ) + 1;
function _rows_auto() = floor( (plate_depth - (_T()+_B())) / _pitch_h() ) + 1;

function _cols() = auto_fit ? max(1,_cols_auto()) : _cols_auto();
function _rows() = auto_fit ? max(1,_rows_auto()) : _rows_auto();

function _span_cols() = (_cols()-1)*_pitch_h();
function _span_rows() = (_rows()-1)*_pitch_h();

function _slack_x() = (plate_width - (_L()+_R())) - _span_cols();
function _slack_y() = (plate_depth - (_T()+_B())) - _span_rows();

function _x0() = (lock_symmetry=="On") ? (_L() + _slack_x()/2) : _L();
function _y0() = (lock_symmetry=="On") ? (_T() + _slack_y()/2) : _T();

function cx(ix) = _x0() + ix*_pitch_h();
function cy(iy) = _y0() + iy*_pitch_h();

// ---------- primitives ----------
module hole_at(cx,cy){
    translate([cx,cy,-0.1]) cylinder(h=plate_thickness+0.4, d=actual_hole_d);
    if (lead_in_on)
        translate([cx,cy,plate_thickness - lead_in_height + 0.1])
            cylinder(h=lead_in_height, d1=actual_hole_d*lead_in_factor, d2=actual_hole_d);
}

// ----- Spherical cup cutter (robust, slicer-friendly) -----
module cup_spherical_at(cx, cy) {
    // Effective depth (honor minimum floor)
    h_req = cup_depth;
    h_max = max(0.1, plate_thickness - cup_floor_min);
    h_eff = min(h_req, h_max);

    // Sphere that matches the rim diameter at depth h_eff
    Ds = actual_hole_diameter;                    // same rim Ø as holes
    R  = (h_eff*h_eff + (Ds/2)*(Ds/2)) / (2*h_eff);
    zc = plate_thickness - (R - h_eff);      // sphere center z at top-open bowl

    // Clip slightly below the tangent plane to avoid coplanar artifacts
    eps = 0.05;                               // 50 µm; safe for PETG
    z_clip = plate_thickness - h_eff - eps;

    // Subtract only the spherical cap ABOVE z_clip (no cylindrical segment)
    intersection() {
        translate([cx, cy, zc]) sphere(r = R, $fn = 96);
        translate([-1e3, -1e3, z_clip])
            cube([2e3, 2e3, 2e3], center = false);
    }

    // Optional drain (only when enabled)
    if (cup_drain_enable)
        translate([cx, cy, -0.2]) cylinder(h = plate_thickness + 0.6,
                                           d = cup_drain_diam, $fn = 32);
}

// ---------- plates ----------
module plate_holes(){
    difference(){
        cube([plate_width, plate_depth, plate_thickness]);
        for (ix=[0:_cols()-1])
        for (iy=[0:_rows()-1])
            hole_at(cx(ix), cy(iy));
    }
}

// ----- Bottom plate (Cups) -----
module plate_cups() {
    difference() {
        // base plate
        cube([plate_width, plate_depth, plate_thickness]);

        // subtract spherical cups ONLY (no cylinders here)
        // reuse the SAME XY grid you use for the holes plate
        holes_width = (grid_columns - 1) * hole_spacing + actual_hole_d;
        holes_depth = (grid_rows    - 1) * hole_spacing + actual_hole_d;
        offset_x = (plate_width - holes_width) / 2;
        offset_y = (plate_depth - holes_depth) / 2;

        for (x = [0:grid_columns-1]) {
            for (y = [0:grid_rows-1]) {
                cx = offset_x + (x * hole_spacing) + (actual_hole_d/2);
                cy = offset_y + (y * hole_spacing) + (actual_hole_d/2);
                cup_spherical_at(cx, cy);
            }
        }
    }
}


// ---------- end piece ----------
function _stack_height_2tiers() = pf_bottom_foot + 2*plate_thickness + pf_tier_spacing + pf_top_cap;
function _pocket_w()  = plate_thickness + pf_pocket_fit;
function _pocket_h()  = plate_thickness - pf_vertical_grip;

module end_piece(){
    cheek_w = pf_cheek_thickness;
    cheek_d = pf_pocket_depth + pf_visible_overlap;
    cheek_h = _stack_height_2tiers();
    difference(){
        cube([cheek_w, cheek_d, cheek_h]);
        // lower pocket (cups plate)
        translate([0, pf_visible_overlap, pf_bottom_foot])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]);
        // upper pocket (holes plate)
        translate([0, pf_visible_overlap, pf_bottom_foot + plate_thickness + pf_tier_spacing])
            cube([cheek_w+0.1, _pocket_w(), _pocket_h()+0.02]);
    }
}

/* Antisera placeholders */
module antisera_cheek(){
    linear_extrude(height=as_cheek_thk)
        polygon(points=[[0,0],[as_cheek_depth,0],[as_cheek_depth, as_tiers*(as_shelf_thk+as_rise)-as_rise],
                        [0,        as_tiers*(as_shelf_thk+as_rise)-as_rise]]);
}
module antisera_shelf(){ plate_holes(); }

// ---------- flat layouts (origin-based, no overlap) ----------
module layout_12x75_flat(){
    gap = 12;
    translate([0,0,0]) end_piece();
    translate([pf_cheek_thickness + gap, 0, 0]) plate_cups();
    translate([pf_cheek_thickness + gap + plate_width + gap, 0, 0]) plate_holes();
}

module layout_antisera_flat(){
    gap = 12;
    translate([0,0,0]) antisera_cheek();
    translate([as_cheek_thk + gap, 0, 0]) antisera_cheek();
    translate([2*(as_cheek_thk + gap), 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + plate_width + gap, 0, 0]) antisera_shelf();
    translate([2*(as_cheek_thk + gap) + 2*(plate_width + gap), 0, 0]) antisera_shelf();
}

// ---------- exporter ----------
if (rack_family == "12x75 Test Tube Rack"){
    if (export_part == "All parts (flat)")        layout_12x75_flat();
    else if (export_part == "Plate - Holes only") plate_holes();
    else if (export_part == "Plate - Cups only")  plate_cups();
    else if (export_part == "End piece only")     end_piece();
    else                                          layout_antisera_flat();
} else {
    layout_antisera_flat();
}
