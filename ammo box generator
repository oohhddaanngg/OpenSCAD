// Ammo Box with Screw-On Lid v1.0
// by Oohhddaanngg (MTin3D)
// Purpose: Fully parametric round container with internal cartridge holes and a screw-on lid.
// Notes:
// - Printable coarse triangular thread (external on body, internal in lid).
// - Hex-ring hole arrangement: center + rings of 6, 12, 18...
// - UI follows MakerWorld rules: help line above, range on same line.

// ---------- Global / Quality ----------
/* [Print Settings] */
// Detail multiplier for curve resolution (higher = smoother, slower)
detail_level = 1.0; // [0.8:0.1:1.6]
base_fn = max(48, min(160, floor(64*detail_level)));
$fn = base_fn; $fa = 6; $fs = 0.8;

// ==============================
// [1] Container Dimensions
// ==============================
/* [Container] */
// Outer diameter of the body (mm)
body_outer_d = 70; // [50:1:120]
// Inner height available for rounds (mm) — excludes floor thickness
body_inner_h = 60; // [30:1:140]
// Wall thickness (mm)
wall_thickness = 2.0; // [1.2:0.2:4.0]
// Floor thickness (mm)
floor_thickness = 3.0; // [2.0:0.5:6.0]

// ==============================
// [2] Threading
// ==============================
/* [Threading] */
// Thread pitch (mm per turn)
thread_pitch = 3.0; // [2.0:0.2:5.0]
// Radial thread depth (crest-to-root) (mm)
thread_depth = 1.2; // [0.8:0.1:2.0]
// Radial clearance between body crest and lid root (mm)
thread_clearance = 0.35; // [0.2:0.05:0.6]
// Axial thread height on body (mm)
thread_height = 12; // [8:1:20]
// Lead-in chamfer height for easier start (mm)
thread_leadin_h = 2.0; // [0:0.5:4.0]

// ==============================
// [3] Lid
// ==============================
/* [Lid] */
// Lid wall thickness (mm)
lid_wall_thickness = 2.2; // [1.2:0.2:4.0]
// Lid top thickness (mm)
lid_top_thickness = 3.0; // [2.0:0.5:6.0]
// Knurl depth on lid rim (mm)
lid_knurl = 0.8; // [0:0.2:1.5]

// ==============================
// [4] Rounds / Hole Array
// ==============================
/* [Rounds] */
// Cartridge hole diameter (mm) — add small slack vs actual case OD
hole_diameter = 10.5; // [6:0.1:16]
// Number of rounds/holes to place
hole_count = 25; // [1:1:200]
// Clearance between holes (mm) — wall between holes
hole_gap = 1.0; // [0.5:0.1:2.0]
// Edge clearance to inner wall (mm)
edge_clearance = 1.2; // [0.6:0.1:2.5]

// ==============================
// [5] Export
// ==============================
/* [Export] */
// Choose which part to export
export_mode = "Both"; // [Body, Lid, Both]

// ---------- Helpers ----------
function clampv(x,a,b) = min(max(x,a),b);
function mm(x) = x; // semantic

// Derived radii/heights
inner_d = body_outer_d - 2*wall_thickness;
inner_r = inner_d/2;
body_total_h = body_inner_h + floor_thickness + thread_height + 0.2; // shoulder under thread

// Thread major/minor diameters (body external thread)
thread_major_d = body_outer_d - 0.4; // small shoulder inset from outer wall
thread_minor_d = thread_major_d - 2*thread_depth;

// Lid internal thread mates with body external; add clearance on radius
lid_thread_minor_d = thread_major_d + 2*thread_clearance; // lid's inner diameter at root
lid_thread_major_d = lid_thread_minor_d + 2*thread_depth;

// ---------- Hex-ring hole packing (center + rings of 6k) ----------
// Returns the radius for ring k (k=0 => center), based on hole_diameter and gap.
function ring_radius(k, hd, gap) = (k==0) ? 0 : k*(hd + gap);

// Returns capacity for K rings including center: 1 + 3*K*(K+1)
function capacity_for_rings(K) = 1 + 3*K*(K+1);

// Compute maximum rings that fit within inner_r (respecting edge clearance)
function max_rings_fitting(r_in, hd, gap, edge) =
    let(maxk = floor( (r_in - edge - hd/2) / (hd + gap) ))
    max(0, maxk);

// Place holes up to hole_count; returns nothing (used in module)
module place_holes(count, hd, gap, edge){
    rings_max = max_rings_fitting(inner_r, hd, gap, edge);
    cap = capacity_for_rings(rings_max);
    if (count > cap) echo("Warning: Requested holes exceed capacity (", count, " > ", cap, "). Some will be omitted.");

    remaining = count;

    // center
    if (remaining > 0){
        translate([0,0, floor_thickness]) cylinder(h=body_inner_h+0.2, d=hd, $fn=base_fn);
        remaining = remaining - 1;
    }

    // rings
    for (k=[1:rings_max]){
        n_on_ring = min(6*k, remaining);
        if (n_on_ring <= 0) break;
        r = ring_radius(k, hd, gap);
        for (i=[0:n_on_ring-1]){
            ang = 360/n_on_ring * i;
            translate([r*cos(ang), r*sin(ang), floor_thickness])
                cylinder(h=body_inner_h+0.2, d=hd, $fn=base_fn);
        }
        remaining = remaining - n_on_ring;
    }
}

// ---------- Thread primitives (coarse triangular, printable) ----------
// We approximate a single-start triangular thread by tessellating helical wedges.
// Segmented approach is robust & fast on MakerWorld (no external libs).

// 2D triangular tooth in "circumferential vs radial" local space.
module tooth2d(pitch, depth){
    polygon(points=[[0,0],[pitch/2,depth],[pitch,0]]);
}

// External helical thread wrapped around radius R.
// segments: angular segmentation count (more = smoother, slower)
module external_thread(R, pitch, depth, height, leadin_h=0, segments=48){
    turns = height/pitch;
    seg_ang = 360/segments;
    arc_len = 2*3.1415926536*R/segments; // circumferential width per segment

    // slight taper on start for easier engagement
    lead = min(leadin_h, height);
    union(){
        for (s=[0:segments-1]){
            rotate(s*seg_ang)
                translate([R,0,0])
                    linear_extrude(height=height, twist=turns*seg_ang)
                        translate([0,0])
                            scale([arc_len/pitch,1])
                                tooth2d(pitch, depth);
        }
        // axial chamfer at start
        if (lead > 0)
            translate([0,0,0]) cylinder(h=lead, r1=R+depth, r2=R, $fn=base_fn);
    }
}

// Internal thread: subtract a "negative" external thread with clearance baked in.
module internal_thread(R_root, pitch, depth, height, leadin_h=0, segments=48){
    // R_root corresponds to inner radius at thread root in the lid.
    external_thread(R_root, pitch, depth, height, leadin_h, segments);
}

// ---------- Main Components ----------
// Body with external thread & hole array
module body_with_holes(){
    difference(){
        // Outer body
        cylinder(h=body_total_h, d=body_outer_d, $fn=base_fn);

        // Bore interior
        translate([0,0,floor_thickness])
            cylinder(h=body_total_h, d=inner_d, $fn=base_fn);

        // Thread relief under thread minor (shoulder)
        translate([0,0, body_inner_h + floor_thickness])
            cylinder(h=thread_height+0.4, d=thread_minor_d-0.2, $fn=base_fn);

        // Cartridge holes
        place_holes(hole_count, hole_diameter, hole_gap, edge_clearance);
    }

    // External thread on the upper outside
    translate([0,0, body_inner_h + floor_thickness])
        external_thread(R=thread_major_d/2 - thread_depth, 
                        pitch=thread_pitch, 
                        depth=thread_depth, 
                        height=thread_height,
                        leadin_h=thread_leadin_h,
                        segments=max(36, floor(48*detail_level)));
}

// Lid with internal thread
module lid(){
    lid_outer_d = body_outer_d + 2*lid_wall_thickness;
    lid_total_h = lid_top_thickness + thread_height + 2.0;

    // Solid shell
    difference(){
        // Outer
        cylinder(h=lid_total_h, d=lid_outer_d, $fn=base_fn);

        // Inner cavity (room for thread and top clearance)
        translate([0,0,lid_top_thickness])
            cylinder(h=lid_total_h, d=lid_thread_minor_d + 0.2, $fn=base_fn);

        // Carve internal thread (subtract)
        translate([0,0,lid_top_thickness])
            internal_thread(R_root=lid_thread_minor_d/2,
                            pitch=thread_pitch,
                            depth=thread_depth,
                            height=thread_height,
                            leadin_h=thread_leadin_h,
                            segments=max(36, floor(48*detail_level)));
    }

    // Simple knurl (optional)
    if (lid_knurl > 0){
        kn_cnt = 24;
        for (i=[0:kn_cnt-1]){
            ang = 360/kn_cnt * i;
            rotate([0,0,ang])
                translate([(lid_outer_d/2)-lid_knurl/2,0,lid_top_thickness*0.3])
                    cube([lid_knurl, lid_knurl*0.7, lid_total_h - lid_top_thickness*0.6], center=true);
        }
    }
}

// ---------- Export ----------
spacing = body_outer_d/2 + (body_outer_d + 2*lid_wall_thickness)/2 + 10;

if (export_mode == "Body"){
    body_with_holes();
} else if (export_mode == "Lid"){
    lid();
} else {
    body_with_holes();
    translate([spacing,0,0]) lid();
}

// ---------- Validation & Hints ----------
if (inner_d <= 0 || body_inner_h <= 0) echo("ERROR: Dimensions produce no interior.");
if (thread_minor_d <= 0) echo("ERROR: Thread depth too large for major diameter.");
if (hole_diameter + hole_gap > inner_d) echo("Warning: Hole diameter + gap exceeds container width.");

echo(str("Hint: For smooth threads, use 0.20–0.28 mm layers and set thread_clearance >= ",
         0.30, " mm for PLA (PETG/ABS can be ~0.25 mm)."));
